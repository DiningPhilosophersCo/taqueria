// Generated by ts-to-zod
import { z } from 'zod';

const todoSchema = z.object({
	notDoneYet: z.literal(true),
});

export const nonEmptyStringSchema = z.string().min(1);

export const singleCharSchema = z.string().regex(/^[A-Za-z]$/);

export const verbSchema = z.string().regex(/^[A-Za-z\-\ ]+/);

export const aliasSchema = z.union([verbSchema, singleCharSchema]);

export const humanReadableIdentifierSchema = z
	.string()
	.regex(/^[A-Za-z]+[A-Za-z0-9-_ ]*$/);

export const sanitizedAbsPathSchema = z.string();

export const sanitizedPathSchema = z.string().regex(/^(\.\.|\.\/|\/)/);

export const settingsSchema = z.object({
	consent: z.union([z.literal('opt_in'), z.literal('opt_out')]),
});

export const commandSchema = z.string();

export const optionSchema = z.object({
	shortFlag: singleCharSchema.optional(),
	flag: verbSchema,
	description: nonEmptyStringSchema,
	defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
	type: z.union([z.string(), z.number(), z.boolean()]).optional(),
	required: z.boolean().optional(),
	boolean: z.boolean().optional(),
	choices: z.array(z.string()).optional(),
});

export const positionalArgSchema = z.object({
	placeholder: humanReadableIdentifierSchema,
	description: nonEmptyStringSchema,
	defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
	type: z.union([z.string(), z.number(), z.boolean()]).optional(),
	required: z.boolean().optional(),
});

export const installedPluginSchema = z.object({
	type: z.union([z.literal('npm'), z.literal('binary'), z.literal('deno')]),
	name: z.string(),
});

export const pluginActionNameSchema = z.union([
	z.literal('proxy'),
	z.literal('pluginInfo'),
	z.literal('checkRuntimeDependencies'),
	z.literal('installRuntimeDependencies'),
	z.literal('proxyTemplate'),
]);

export const pluginJsonResponseSchema = todoSchema;

export const pluginResponseEncodingSchema = todoSchema;

export const requestArgsSchema = todoSchema;

export const economicalPrototypeHashSchema = z
	.string()
	.regex(/^P[A-Za-z0-9]{50}$/);

export const publicKeyHashSchema = z.string().regex(/^tz1[A-Za-z0-9]{33}$/);

export const sha256Schema = z.string().regex(/^[A-Fa-f0-9]{64}$/);

export const contractSchema = z.object({
	sourceFile: z.string(),
	hash: sha256Schema,
});

export const faucetSchema = z.object({
	pkh: publicKeyHashSchema,
	mnemonic: z.array(z.string()),
	email: z.string().email(),
	password: z.string(),
	amount: z.string().regex(/^\d+$/),
	activation_code: z.string(),
});

export const persistentStateSchema = todoSchema;

export const operationSchema = z.object({
	operation: verbSchema,
	command: commandSchema,
	description: z.string().optional(),
	positionals: z.array(positionalArgSchema).optional(),
	options: z.array(optionSchema).optional(),
	handler: z
		.function()
		.args(persistentStateSchema)
		.returns(z.function().args(requestArgsSchema).returns(z.void()))
		.optional(),
});

export const parsedOperationSchema = operationSchema.omit({ handler: true });

const templateHandlerSchema = z.union([
	nonEmptyStringSchema,
	z
		.function()
		.args(requestArgsSchema)
		.returns(
			z.union([
				z.void(),
				pluginJsonResponseSchema,
				z.promise(z.void()),
				z.promise(z.promise(z.void())),
				z.promise(pluginJsonResponseSchema),
			]),
		),
]);

export const templateSchema = z.object({
	template: verbSchema,
	command: commandSchema,
	description: z.string().min(4),
	hidden: z.boolean().optional(),
	options: optionSchema.optional(),
	positionals: positionalArgSchema.optional(),
	handler: templateHandlerSchema,
	encoding: pluginResponseEncodingSchema,
});

export const parsedTemplateSchema = templateSchema.and(
	z.object({
		handler: z.string(),
		encoding: pluginResponseEncodingSchema,
	}),
);
